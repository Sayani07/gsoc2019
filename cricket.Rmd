---
title: "Fun T20 cricket analysis "
author: "Sayani Gupta"
date: "12/07/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lvplot)
library(ggridges)
library(viridis)
```

Let us imagine a T20 format of cricket to be in a calendar format, where each ball is assumed to represent an unit of time. In such a world, a calendar would look like the following:

hour : ball  
day:  over  
quarter: 5 overs  
semester: 10 overs  
year: 20 overs  

Suppose, we are interested to see how the distribution of scores vary from the start to the end of the game. Let us brainstorm some of the questions that might help us comprehend that.

a) How the score varies across each balls, over, quarter or semester of the game for the number of matches played. 

For example, if the team has played 5 T20 matches and we are interested to know how scores varied for each of those 20*5 = 100 overs, then what we are trying to understand here is the distribution of scores across linear categorization, overs in this case. 


b) How the scores vary per each over of a quarter, or each quarter of a semester each over of a semester? 


We are essentially trying to understand the distribution of scores across periodic categorisations, where each coarser unit consists of equal number of finer units for all levels of the coarser unit. For each match, balls, overs, quarters and semesters can be thought to align linearly where balls vary from 1,2, ..120, overs vary from 1, 2, ...20, quarters range from 1, 2,...,4 and so on. We call these "linear" categorisation if we are just looking at one match.But for 80 matches, these are not "linear" since they keep on repeating themselves within a match. We call these "circular" categorisations. Similarly,  we can also be interested to study the distribution of runs across balls per over/quarter/semester, overs per quarter/semester and quarters per semester. 


What are the exhaustive list of circular categorisation that we can look at here:

 1) balls of an over (ball_over)
 2) balls of a quarter (ball_quarter)
 3) balls of a  semester (ball_semester)
 4) balls of a  match (ball_match)
 5) overs of a quarter (ball_quarter)
 6) overs of a semester (over_semester)
 7) overs of a match (over_match)
 8) quarters of a semester (quarter_semester)
 9) quarters of a match (quarter_match)
 10) semesters of a match (semester_match)


The hierarchy being as follows - 

 - ball
 - over -> 6 balls
 - quarter -> 5 overs
 - semester -> 2 quarters
 - match -> 2 semesters


```{r hierarchy, echo=TRUE}
hierarchy_model <- tibble(category_ls = c("ball", "over", "quarter", "semester", "match"), conversion_fac  = c(6, 5, 2, 2, 1))
hierarchy_model
```


The dataset provides balls per over. Can we compute all other  categorisations given the hierarchy model?

Suppose: $f(x, y)$ represents the functional form for computing x per y. 

$f(ball, quarter) = f(ball, over) + c(ball, over)*[f(over, quarter)-1]$  

and, 

$f(ball, semester) = f(ball, over) + c(ball, over)* [f(over, semester) - 1]$

or, 
$f(ball, semester)                  =  f(ball, over) + c(ball, over)*f(over, quarter) +c(over, quarter)f(quarter, semester)$  
                  
and so on.

In the above equations, it is shown how to obtain f(x,z) given f(x,y) and the hierarchy table,  provided $order(z) > order(y) \neq order(x)$. In general,

 $f(x,z) = \sum_{i=0}^{order(z) - order(y) + 1}c(x, x+i)f(x+1, x+i)$

We could also derive f(w, y) given f(x, y) and the hierarchy table, for $order(y)>=order(w) > order(x)$.

$f(w,y) = f(x,y) \mod c(x,w)$, for $f(x,y) \mod c(x,w)!=0$ \\
        $= c(x,w))$, otherwise.

Let us investigate if that is true:

f(ball, over) = 1
f(over, quarter) = 4
f(quarter, semester) = 2
f(semester, match) = `1

then, f(ball_quarter) = 1 + 6*4 = 25, 
      f(ball, semester) = 1 + 6*4 + 5*6*1 = 55
      f(ball, semester) = 1 + 6*4 + 5*6*1 + 5*6*2*1 = 115

We will look at the ball by ball data for Mumbai Indians.  Performance will vary depending on if they are batting 1st or 2nd. Hence, it is a good idea to filter the matches in which they have batted first.

```{r read_data, echo=TRUE}
# reading ball by ball data
data <-  read_csv("deliveries.csv")


data_MI <- data %>% 
  filter(batting_team =="Mumbai Indians", inning ==1) %>% 
  mutate(quarter_match = case_when(
    
    between(over,1,5) ~ 1,
    between(over,6,10) ~ 2,
    between(over,11,15) ~ 3,
    between(over,16,20) ~ 4
  )) %>% 
   mutate(semester_match = case_when(
    
    between(quarter_match,1,2) ~ 1,
    between(quarter_match,3,4) ~ 2
  )) 
```


```{r nmatch, echo=TRUE}
data_MI %>% distinct(match_id) %>% nrow()
```

# Checking data accuracy  

```{r data_check, echo=TRUE}
data_MI %>% distinct(over) %>% nrow()
data_MI %>% distinct(ball) %>% range()
data_MI %>% distinct(total_runs) %>% range()
```

Each match consists of 20 overs. Total runs per ball ranges from 0 to 7, which also seems sensible. Balls per over ranges from 1 to 9, which seems reasonable in case of no/wide balls. However, we would eliminate such cases so that each over consists of 6 balls. There are 2 matches for which some overs have less than 6 balls. These 2 matches are removed from the dataset. Also rows for which (wide_runs + noball_runs) not equal to zero are removed from the dataset. This would ensure that each over has 6 balls. However, in the dataset the ball index will still range from 1 to 9. The ball index is renamed from 1 to 6 based on the rank. Thus a over in the dataset which has balls (1, 3, 5, 6, 8, 9) will be renamed as (1, 2, 3, 4, 5, 6) so that ball labels are consistent across overs.


```{r}
match_er <- data_MI %>% filter(wide_runs + noball_runs==0) %>% group_by(match_id,over) %>%  summarize(n = n()) %>% filter(n!=6) %>% select(match_id)

nmatch = data_MI$match_id %>% length()
nover = data_MI %>% distinct(over) %>% nrow()

data_MI <- data_MI %>% filter(!match_id  %in% match_er$match_id, wide_runs + noball_runs==0) %>% 
  mutate(balls = purrr::rep_along(match_id, 1:6),
         balls_game =  purrr::rep_along(match_id, 1:120)) %>% 
  select(match_id, over, balls, balls_game,  quarter_match, semester_match,  total_runs)
  

#data_MI %>% group_by(match_id, over) %>% summarise(n = n()) %>% distinct()
```


a) How the score varies across each balls (a simple time plot), over, quarter or semester of the match. What we are trying to understand here is the distribution of scores across linear time units.

```{r balls, echo=TRUE}
# data_MI %>% ggplot(aes(x = as.factor(balls_game), y= total_runs)) +  geom_boxplot()+ xlab("balls")
# data_MI %>% ggplot(aes(y = as.factor(balls_game), x= total_runs)) + geom_density_ridges2() + ylab("Balls per  over")


data_MI_dec <- data_MI %>%
  group_by(balls_game) %>%
  do({x <- .$total_runs
  map_dfr(.x = c(0.25,0.5, 0.75, 0.9),
          .f = ~ tibble(Quantile = .x,
                            Value = quantile(x, probs = .x,na.rm=TRUE)))
  })


data_MI_dec %>%
  ggplot(aes(x = balls_game,y = Value,col = as.factor(Quantile))) +
  geom_step() +
  xlab("Balls per match") + scale_x_continuous(breaks = seq(1, 120, 12)) +
  ggtitle("Quartile plot of total runs per ball across balls per match")

```

From the 1st to 6th ball, looks like the maximum total runs alternate between 6 and 7. The distribution of 1st, 3rd and 5th ball are more similar to each other than that of 2nd, 4th and 6th which also looks pretty close. The 8th and 9th balls in most cases scatters around 0 and 1 as they might be a result of no/wide balls. 

```{r over, echo=TRUE}
data_MI %>% ggplot(aes(x = as.factor(over), y= total_runs)) +  geom_violin()+ xlab("Overs per match") + ggtitle("Violin plot of runs per ball across each over of a match")

# data_MI %>% ggplot(aes(y =as.factor(over), x= total_runs)) + geom_density_ridges2() + ylab("Balls per  over")
```

distribution of first three overs look similar where total runs/ball mostly centers around 0/1. The 4th, 5th and 6th over looks similar where probability of total scores less than 1 decreases.From 7th to 14th over, total runs/ball centers mostly around 1/2. Again from 15th to 20th over, behaviors are similar.


```{r quarter, echo=TRUE}
data_MI %>% ggplot(aes(x = as.factor(quarter_match), y= total_runs)) +  geom_violin()+ xlab("quarters")+ ylab(" Total runs per ball") + ggtitle("Violin plot of runs per ball across each quarter of a match")

# data_MI %>% ggplot(aes(y =as.factor(quarter), x= total_runs)) + geom_density_ridges2() + ylab("quarters per match") + xlab(" Total runs per ball")
```



```{r semester, echo=TRUE}
data_MI %>% ggplot(aes(x = as.factor(semester_match), y= total_runs)) +  geom_violin()+ xlab("semester per match")+ ylab(" Total runs per ball") +ggtitle("Violin plot of runs per ball across each semesters of a match")

data_MI %>% ggplot(aes(x = total_runs, y= as.factor(semester_match))) +  geom_density_ridges2()+ xlab("semesters per match")+ ylab(" Total runs per ball")+ ggtitle("Ridge plot of runs per ball across each semesters of a match")

# data_MI %>% ggplot(aes(y =as.factor(semester), x= total_runs, fill=factor(..quantile..))) +   stat_density_ridges(
#     geom = "density_ridges_gradient", calc_ecdf = TRUE,
#     quantiles = 4, quantile_lines = TRUE
#   )  + ylab("semester") + xlab(" Total runs per ball") +
#   scale_fill_viridis(discrete = TRUE, name = "Quartiles")
```
      

      






